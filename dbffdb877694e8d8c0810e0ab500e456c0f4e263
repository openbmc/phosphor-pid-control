{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "697b5d8e_02acd4ff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 31,
      "author": {
        "id": 1001049
      },
      "writtenOn": "2024-09-29T05:24:07Z",
      "side": 1,
      "message": "Tested section?",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b47507b1_e73a5656",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 31,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-10-01T10:53:06Z",
      "side": 1,
      "message": "Would it be okay if I attach the manual mode status and the phosphor-pid-control logs before and after the changes, following the server board being unplugged and plugged back in?",
      "parentUuid": "697b5d8e_02acd4ff",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c436cc1_4d3c0590",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-09-25T10:14:56Z",
      "side": 1,
      "message": "Currently, the CI has failed with the following summary of failures:\n\n10/14 pid_thermalcontroller_unittest  FAIL             0.89s   exit status 1  \n12/14 dbus_passive_unittest           FAIL             1.39s   exit status 1  \n13/14 sensor_host_unittest            FAIL             1.79s   exit status 1  \n14/14 pid_zone_unittest               FAIL             2.14s   exit status 1  \n\nOk:                 10  \nExpected Fail:      0   \nFail:               4   \nUnexpected Pass:    0   \nSkipped:            0   \nTimeout:            0\n\nThe main issue seems to be:  \n**Conditional jump or move depends on uninitialized value(s)**.  \nHowever, this doesn\u0027t appear to be related to my changes.\nCould the Verify failure be caused by a rebuild of other parts of the code?\n\nThanks!",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d37d7fbe_989f2601",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-09-25T12:22:18Z",
      "side": 1,
      "message": "This is true. It commonly happens. Old code, which passed old CI tests, now fails new CI tests, but the underlying code has not changed. Reason is, the CI testing framework itself undergoes continuous improvements. It becomes smarter, and more capable of catching bad coding practices, than it was earlier. So, it can happen that your patch introduces a CI failure, simply because it has been a long time since this code was last tested with CI, since CI only runs when a newly written patch is uploaded.\n\nThe workaround is to first make appropriate changes to the code to fix the CI errors and get the CI to now pass cleanly. It is encouraged to put these fixes in another patch, as they serve separate purposes. Then, rebase this existing patch, so that it is on top of that new patch. Then, the patch stack should all cleanly pass the CI.",
      "parentUuid": "1c436cc1_4d3c0590",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd8401d0_46e8f087",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-09-26T11:08:24Z",
      "side": 1,
      "message": "Thank you very much for your suggestion. I will try to fix the code causing the CI failure.\n\nHowever, I would like to ask if the way I am currently modifying the manual code complies with the standards, and if there are any adjustments that need to be made.\nI really appreciate your advice.",
      "parentUuid": "d37d7fbe_989f2601",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49938498_d05e10ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-09-27T10:30:23Z",
      "side": 1,
      "message": "I looked at it more. It does seem like it is a lot of code to basically perform one task: stretch the lifetime of the `manual` mode flag within each zone\u0027s data structure, so that it can survive when a configuration change happens that causes the structures to get destroyed and then rebuilt. The zone ID number is used as the invariant, to match each zone up afterwards. Do zone ID numbers ever change? What if a zone is added or removed at runtime?\n\nThat said, the code looks good so far, other than a concern about using `dynamic_cast`, as it relies on compiler RTTI, and I\u0027m not sure if we\u0027re using RTTI for this project or not (I would prefer to not use it, if possible, unless we are already using it). When it\u0027s ready, we will also need to add test cases to test this new feature.",
      "parentUuid": "cd8401d0_46e8f087",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54f6a027_2da9a7c5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1001049
      },
      "writtenOn": "2024-09-29T05:24:07Z",
      "side": 1,
      "message": "Looks good to me.",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce38ccd4_a696bede",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1001049
      },
      "writtenOn": "2024-09-29T05:24:37Z",
      "side": 1,
      "message": "Fix the build issues",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bad13021_4c31f5ca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-10-04T12:41:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "49938498_d05e10ce",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34ec6763_aa6f5e2e",
        "filename": "main.cpp",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-09-27T10:30:23Z",
      "side": 1,
      "message": "Could state::zones ever contain something that is not a DbusPidZone object? Using dynamic_cast could invoke RTTI. Is RTTI enabled for phosphor-pid-control? I didn\u0027t think that it was. I wonder if there\u0027s a different way to do this? Generally, dynamic_cast is considered a code smell, and I feel uneasy about it.",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1722ce8f_e7b1aa05",
        "filename": "main.cpp",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-10-01T10:53:06Z",
      "side": 1,
      "message": "Thank you very much for your suggestion.\nWould it be better to access the zone directly using static_pointer_cast instead of using dynamic_pointer_cast?\nI\u0027ll first try to avoid dynamic_pointer_cast and explore other approaches.",
      "parentUuid": "34ec6763_aa6f5e2e",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc75dc3c_64ebb44d",
        "filename": "main.cpp",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-10-02T22:04:52Z",
      "side": 1,
      "message": "Using `static_pointer_cast` should be fine, as it should not invoke RTTI.\n\nIs it ever possible for `state::zones` to contain a zone that is not of type `DbusPidZone`?",
      "parentUuid": "1722ce8f_e7b1aa05",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eadf68ac_a597188e",
        "filename": "main.cpp",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-10-04T12:41:32Z",
      "side": 1,
      "message": "Thank you for your suggestion. I will switch to static_pointer_cast and check if itâ€™s ever possible for state::zones to contain a zone that is not of type DbusPidZone.\n\nI will keep you updated as I make progress.\nThanks again!",
      "parentUuid": "cc75dc3c_64ebb44d",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f49eed7e_2353df10",
        "filename": "main.cpp",
        "patchSetId": 5
      },
      "lineNbr": 191,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-09-27T10:30:23Z",
      "side": 1,
      "message": "Same comment as above about the usage of dynamic_cast.",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e55f922a_3105d1cd",
        "filename": "main.cpp",
        "patchSetId": 5
      },
      "lineNbr": 191,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-10-01T10:53:06Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f49eed7e_2353df10",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3896e2dc_bb768354",
        "filename": "pid/zone.hpp",
        "patchSetId": 5
      },
      "lineNbr": 76,
      "author": {
        "id": 1001322
      },
      "writtenOn": "2024-09-30T17:50:28Z",
      "side": 1,
      "message": "where is it getting used?",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b8965262_0ebe3d75",
        "filename": "pid/zone.hpp",
        "patchSetId": 5
      },
      "lineNbr": 76,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-10-01T10:53:06Z",
      "side": 1,
      "message": "In line 136 of main.cpp, the beginning of restartControlLoops stores the current manual mode status (true or false) of the zone, and restores it after buildZones is called.",
      "parentUuid": "3896e2dc_bb768354",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}