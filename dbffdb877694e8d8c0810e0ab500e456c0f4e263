{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1c436cc1_4d3c0590",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-09-25T10:14:56Z",
      "side": 1,
      "message": "Currently, the CI has failed with the following summary of failures:\n\n10/14 pid_thermalcontroller_unittest  FAIL             0.89s   exit status 1  \n12/14 dbus_passive_unittest           FAIL             1.39s   exit status 1  \n13/14 sensor_host_unittest            FAIL             1.79s   exit status 1  \n14/14 pid_zone_unittest               FAIL             2.14s   exit status 1  \n\nOk:                 10  \nExpected Fail:      0   \nFail:               4   \nUnexpected Pass:    0   \nSkipped:            0   \nTimeout:            0\n\nThe main issue seems to be:  \n**Conditional jump or move depends on uninitialized value(s)**.  \nHowever, this doesn\u0027t appear to be related to my changes.\nCould the Verify failure be caused by a rebuild of other parts of the code?\n\nThanks!",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d37d7fbe_989f2601",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-09-25T12:22:18Z",
      "side": 1,
      "message": "This is true. It commonly happens. Old code, which passed old CI tests, now fails new CI tests, but the underlying code has not changed. Reason is, the CI testing framework itself undergoes continuous improvements. It becomes smarter, and more capable of catching bad coding practices, than it was earlier. So, it can happen that your patch introduces a CI failure, simply because it has been a long time since this code was last tested with CI, since CI only runs when a newly written patch is uploaded.\n\nThe workaround is to first make appropriate changes to the code to fix the CI errors and get the CI to now pass cleanly. It is encouraged to put these fixes in another patch, as they serve separate purposes. Then, rebase this existing patch, so that it is on top of that new patch. Then, the patch stack should all cleanly pass the CI.",
      "parentUuid": "1c436cc1_4d3c0590",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd8401d0_46e8f087",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2024-09-26T11:08:24Z",
      "side": 1,
      "message": "Thank you very much for your suggestion. I will try to fix the code causing the CI failure.\n\nHowever, I would like to ask if the way I am currently modifying the manual code complies with the standards, and if there are any adjustments that need to be made.\nI really appreciate your advice.",
      "parentUuid": "d37d7fbe_989f2601",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49938498_d05e10ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-09-27T10:30:23Z",
      "side": 1,
      "message": "I looked at it more. It does seem like it is a lot of code to basically perform one task: stretch the lifetime of the `manual` mode flag within each zone\u0027s data structure, so that it can survive when a configuration change happens that causes the structures to get destroyed and then rebuilt. The zone ID number is used as the invariant, to match each zone up afterwards. Do zone ID numbers ever change? What if a zone is added or removed at runtime?\n\nThat said, the code looks good so far, other than a concern about using `dynamic_cast`, as it relies on compiler RTTI, and I\u0027m not sure if we\u0027re using RTTI for this project or not (I would prefer to not use it, if possible, unless we are already using it). When it\u0027s ready, we will also need to add test cases to test this new feature.",
      "parentUuid": "cd8401d0_46e8f087",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34ec6763_aa6f5e2e",
        "filename": "main.cpp",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-09-27T10:30:23Z",
      "side": 1,
      "message": "Could state::zones ever contain something that is not a DbusPidZone object? Using dynamic_cast could invoke RTTI. Is RTTI enabled for phosphor-pid-control? I didn\u0027t think that it was. I wonder if there\u0027s a different way to do this? Generally, dynamic_cast is considered a code smell, and I feel uneasy about it.",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f49eed7e_2353df10",
        "filename": "main.cpp",
        "patchSetId": 5
      },
      "lineNbr": 191,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-09-27T10:30:23Z",
      "side": 1,
      "message": "Same comment as above about the usage of dynamic_cast.",
      "revId": "dbffdb877694e8d8c0810e0ab500e456c0f4e263",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}