{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1589098b_23c097ea",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2023-12-15T00:50:45Z",
      "side": 1,
      "message": "Good idea, I have a suggestion for an alternate implementation that would just compute the failsafe value whenever needed, instead of trying to compute it at addition/removal time which can get out of sync quickly if additions and removals come in random order.",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cca113c8_1d61da8f",
        "filename": "pid/zone.cpp",
        "patchSetId": 10
      },
      "lineNbr": 110,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2023-12-15T00:50:45Z",
      "side": 1,
      "message": "Instead of tracking a separate variable `_failSafePercent` as a class member, I would feel better if this value was computed every time it was needed. Sweep the list of failsafe sensors and take the maximum. Failsafe is not the standard condition, so it is OK to take a few extra CPU cycles here. The logic would become simpler and safer, especially as sensors are added and removed independently of each other.",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "911cac0a_acc0eae2",
        "filename": "pid/zone.cpp",
        "patchSetId": 10
      },
      "lineNbr": 110,
      "author": {
        "id": 1000847
      },
      "writtenOn": "2023-12-19T07:29:02Z",
      "side": 1,
      "message": "Update the algorithm. Done.",
      "parentUuid": "cca113c8_1d61da8f",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ba4b9d9_8e0c645f",
        "filename": "pid/zone.cpp",
        "patchSetId": 10
      },
      "lineNbr": 160,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2023-12-15T00:50:45Z",
      "side": 1,
      "message": "Again, please use `NaN` instead of testing for zero here.",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d4bdb149_98f58912",
        "filename": "pid/zone.cpp",
        "patchSetId": 10
      },
      "lineNbr": 160,
      "author": {
        "id": 1000847
      },
      "writtenOn": "2023-12-19T07:29:02Z",
      "side": 1,
      "message": "In dbus/dbusconfiguration.cpp, the default sensor failsafepercent is 0 if there is no setting in json(Added these to comment). So I still detect if max failsafe duty is `0` or not.\nUpdate the algorithm.",
      "parentUuid": "4ba4b9d9_8e0c645f",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c558b7e_be632593",
        "filename": "pid/zone.cpp",
        "patchSetId": 10
      },
      "lineNbr": 543,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2023-12-15T00:50:45Z",
      "side": 1,
      "message": "This logic can be simplified, see the algorithm in my above comment. I feel this should be done as needed, instead of trying to maintain a cached value.",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3719b5e1_7b055c0d",
        "filename": "pid/zone.cpp",
        "patchSetId": 10
      },
      "lineNbr": 543,
      "author": {
        "id": 1000847
      },
      "writtenOn": "2023-12-18T08:12:05Z",
      "side": 1,
      "message": "I don\u0027t quite understand what `trying to maintain a cached value` means.\nThis function only do in the initial pid/builder.cpp.",
      "parentUuid": "1c558b7e_be632593",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2cbe4993_fb0bf2c3",
        "filename": "pid/zone.cpp",
        "patchSetId": 10
      },
      "lineNbr": 543,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2023-12-20T22:13:09Z",
      "side": 1,
      "message": "I meant to suggest to compute the value at the moment it is needed, just in time, instead of trying to compute the value in advance and then store it for later use. This will solve the bug of what happens when a sensor is removed from the failsafe list which would cause the previously cached failsafe duty to now become incorrect. The correct behavior would be to scan all sensors remaining in the failsafe list and recompute the value. It is easiest just to do this at runtime. It takes slightly more CPU, true, but failsafe is not expected to be a normal running situation.",
      "parentUuid": "3719b5e1_7b055c0d",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9ae9d26_d9d81077",
        "filename": "pid/zone.cpp",
        "patchSetId": 10
      },
      "lineNbr": 543,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2024-05-30T00:24:11Z",
      "side": 1,
      "message": "Thanks for doing this cleanup to the logic.",
      "parentUuid": "2cbe4993_fb0bf2c3",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a9f145a_9990db54",
        "filename": "pid/zone.hpp",
        "patchSetId": 10
      },
      "lineNbr": 201,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2023-12-15T00:50:45Z",
      "side": 1,
      "message": "If the failsafe sensors list is non-empty, then the failsafe percentage will remain unchanged, instead of falling back down to the next highest percentage that is still in the list, which would be the expected behavior.\n\nThis seems like a bug to me, and could be averted by computing the failsafe value as needed, based on the contents of the failsafe sensor list (and the corresponding failsafe values for each of these sensors), instead of trying to maintain a cached value that can quickly become out of sync.",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf12ba31_26290ce2",
        "filename": "pid/zone.hpp",
        "patchSetId": 10
      },
      "lineNbr": 201,
      "author": {
        "id": 1000847
      },
      "writtenOn": "2023-12-18T08:12:05Z",
      "side": 1,
      "message": "Oh, yeah...something\u0027s wrong here. I will fix it. Thanks.",
      "parentUuid": "0a9f145a_9990db54",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "58bd233b_e75baf6c",
        "filename": "pid/zone.hpp",
        "patchSetId": 10
      },
      "lineNbr": 201,
      "author": {
        "id": 1000847
      },
      "writtenOn": "2023-12-19T07:29:02Z",
      "side": 1,
      "message": "Update the algorithm. Done.",
      "parentUuid": "bf12ba31_26290ce2",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "deb9bdd0_bd8d9c8e",
        "filename": "pid/zone.hpp",
        "patchSetId": 10
      },
      "lineNbr": 218,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2023-12-15T00:50:45Z",
      "side": 1,
      "message": "Instead of using zero as a \"not active\" flag, please use `std::numeric_limits\u003cdouble\u003e::quiet_NaN()`. This variable is a floating-point number, so using `NaN` is the safest and most standard way of flagging a value as not filled in yet.",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d38fce2_14356f90",
        "filename": "pid/zone.hpp",
        "patchSetId": 10
      },
      "lineNbr": 218,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2023-12-15T00:50:45Z",
      "side": 1,
      "message": "I would feel better if `_failSafePercent` was not a variable here, but instead, computed when needed. We already have all the necessary information. Here\u0027s an example algorithm:\n\nInitialize to the `_zoneFailSafePercent` value. Then, iterate through each sensor name in the `_failSafeSensors` list. For each sensor name, look up the corresponding failsafe value from the `_sensorFailSafePercent` map. Take the maximum of these values. The resulting final maximum is the failsafe value to use, for the fans in this zone.\n\nThis algorithm should be safe and easy to do when needed, instead of having to worry about maintaining the cached value correctly for each addition and removal of a sensor from the `_failSafeSensors` list, especially if the additions and removals come in random order.",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dae29ecf_3e0a70c0",
        "filename": "pid/zone.hpp",
        "patchSetId": 10
      },
      "lineNbr": 218,
      "author": {
        "id": 1000847
      },
      "writtenOn": "2023-12-18T08:12:05Z",
      "side": 1,
      "message": "Hi Josh, let me clarify.\nThe Original my method \u003d\u003e\n1. `addPidFailSafePercent` only do at the beginning(pid/builder.cpp).\nThe result `_sensorFailSafePercent` map will like below(if EM json has the setting),\n```\n{sensorA, sensorA_failsafe_duty},\n{sensorB, sensorB_failsafe_duty},\n{sensorC, sensorC_failsafe_duty},\n{sensorD, sensorD_failsafe_duty},\n...\n...\n...\n```\n2. when detecting sensor failed each pid loop, will insert sensor name to `_failSafeSensors`, and get sensor failsafe duty from `_sensorFailSafePercent` then compare and update the zone\u0027s `_failSafePercent` variable.\n3. In final `fancontroller.cpp` output will print log for all fail sensor name in `_failSafeSensors` and final failsafe duty `_failSafePercent`.\n\nIf I understand correctly, you mean \u003d\u003e\nI can modify the `_failSafePercent` from variable to vector or other struct and insert all fail sensor\u0027s duty into it. And determine the maximum value in final `getFailSafePercent`?",
      "parentUuid": "0d38fce2_14356f90",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "85848aca_da0c3b30",
        "filename": "pid/zone.hpp",
        "patchSetId": 10
      },
      "lineNbr": 218,
      "author": {
        "id": 1000847
      },
      "writtenOn": "2023-12-19T07:29:02Z",
      "side": 1,
      "message": "Update the algorithm. Done.",
      "parentUuid": "deb9bdd0_bd8d9c8e",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9e0aac29_4813406a",
        "filename": "pid/zone.hpp",
        "patchSetId": 10
      },
      "lineNbr": 218,
      "author": {
        "id": 1000847
      },
      "writtenOn": "2023-12-19T07:29:02Z",
      "side": 1,
      "message": "Update the algorithm. Done.",
      "parentUuid": "dae29ecf_3e0a70c0",
      "revId": "94c82b935d50161756ca3a545ec16acdf7e17985",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}